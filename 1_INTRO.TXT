OS BY GALVIN FOR PAPER
PROGRAM ARE SET OF INSTRUCTION NOT IN EXECUTION AND THOSE THAT ARE IN EXECUTION ARE PROCESS

OS IS BASICALLY A SYSTEM SOFTWARE AND ITS BASIC FUNCTIONALLY IS THAT IT WORKS AS A INTERFACE BETWEEN USER/APPLICATION AND HARDWARE (CPU,I/O DEVIES,RAM ,PRINTER,SCANNER,ETC)WE ACCESS 
HARDWARE USING OPERATING SYSTEM 
OS SUPPORTS SYSTEM SOFTWARES LIKE HARDWARE DRIVERS (THEY ARE IN BUILT),TWO TYPES-COMMAND LINE INTERFACE AND           INTERFACE 

GOALS OF AN OS-CONVENIENCE,EFFICIENCY OR THROUGHPUT,ACCURATE,USER FRIENDLY,MANAGEMENT OF SHARED RESOUCRES
ROLES OF OS-TWO TYPES-1 HARDWARE/SYSTEM 2 SOFTWARE/USER BASED 
                      1 USER VIEW-EFFICIENCY,USER FRIENDLY,SECURED ,NOTE MANAGEMENT OF SHARED RESOURCES IS NOT NEEDED AS WE DONT SHARE PERSONAL HARDWARE SO NO MANAGEMENT NEEDED
                      2 SYSTEM VIEW-


HARDWARE
OS
SYSTEM SOFTWARE,APPLICATIONS,PROGRAM,SOFTWARE

FUNCTIONALITY OF OS
PROCESS MANAGEMENT,MEMORY MANAGEMENT,STORAGE MANAGEMENT(hard disk,SSD),SECURITY AND PRIVACY(LOGIN WINDOW),
(extra-HANDLES INPUT AND OUTPUT LIKE PRINTING,CONTROLS PERIPHERAL DEVICES LIKE DISK DRIVES,)
                      

WHY DO WE NEED OS?-WE NEED A PROGRAM TO ACCESS AND USE A CERTAIN DEVICE,EVERY DEVICE HAS A DIFFERENT PROGRAM BUT WRITING IT AGAIN AND AGAIN WILL BE TIRING SO WE CREATE A DEFAULT OS 




TYPE OF OS 
BATCH-INTIALL WHEN OS WAS DEVELOPED THEY WERE RAN ON REALLY BIG MACHINES WHICH REQUIRED FLOPPY DISKS SO WHEN WE WANTED TO PERFORM PROGRAM AND DO STUFF WE DISTRIBUTED THEM INTO MULTIPLY FLOPPY AND THE OS CONVERTED THEM/MEMORY INTO BATCHES AND THEN PUT THEM ON PROCESSING ,NO CONCEPT OF MAIN MEMORY,FORTRAN WAS THE COMPILER ,IBM 

MULTIPLE PROGRAMMIMG-NO CONCEPT OF BATCHES OR SHARED MEMORY,ALL OF IT WAS THE MAIN MEMORY,IN THIS CASE 2 PROGRAM WOULD GO INTO SYSTEM ONE AT A TIME,CPU WILL EXECUTE IT,IF IT IN CASE IT REQUIRES INPUT AND OUTPUT THEN CPU WOULD BE IDEAL 

MULTITASKING-THIS WAS FOUND FOR EFFICIENCY,THERE IS ONE CPU,IF ONE PROCESS IS INTERRUPTED LIKE INPUT OUT THEN NEXT PROCESS WOULD START/FETCH

MULTIPROCESSING-EACH CPU HAS ITS OWN PROCESS,AND ALL OF THESE PROCESSES MUST BE COMMON/SHARED TO THE MAIN MEMORY 

REALTIME-TO TELL IF SYSTEM IS FULLY DEDICATED TO OUR EACH PROCESS ,EACH PROCESS WILL BE GIVEN THEIR OWN TIMES ,THERE IS A TIME CONTRAINT ON EACH PROCESS,

DISTRIBUTED-EXAMPLE INTERNET,DIFF PEOPLE ON DIFF CPU WORK ON TASKS EACH HAVING DIFFERENT CPUS AND RAMS AND MEMORIES BUT THEY ALL SYNCHORINISE THEIR PROCESS ,FULLY DEDICATED

CLUSTERING-ALL NODES INSIDE THE CLUSTER,MASTER NODES AND OTHER SMALLER NODES 

EMBEDDED-BASIC INPUT OUTPUT OS ,ALSO KNOWN AS FIRMWARE,ALL MICROCONTROLLERS ARE CONTROLLED BY THIS ,BIOS IS ALSO AN EMBEDDED OS ,IT DEALS DIRECTLY WITH HARDWARE AND HAS VERY LESS FUNCTIONALITY COMPARED LESS TO OTHERS ,MAX OS IN ROBOTICS ARE EMBEDDED,AND IT IS EASILY FAST COMMUCATION PROVIDANCE,EACH CHIPSET/HARDWARE HAS DIFFERENT OS,THEN ON TOP OF THAT WE HAVE ANOTHER OS ON TOP OF THAT 



#DUAL MODE OF THE OPERATING SYSTEM
1 USER MODE-ANY PROGRAM IS POSSIBLE TO RUN BUT WHEN ANY NEED TO ACCESS ANY KERNEL OR ANY PERMISSION IT REQUIRES KERNEL 
IT I DONE BECAUSE DUE SECURITY REASONS,so that any program needs permission to access our os code because in case if the program is malicious it can hack our os after accessing our kernel by running malicious commands and codes in the kernel

USER PROGRAM----SYSTEM CALL----|(BIT=1)                               |(BIT=1)----PROGRAM EXECUTED
                               |                                      |
                        (BIT=0)|----EXECUTION OF PROGRAM IN KERNEL----|(BIT=0)
2 KERNEL MODE-REQUIRES PERMISSION FOR DOING SOMETHING OR INSTALLING OR OPENING A PROGRAM AS AN ADMINISTRATOR 

to enter kernel from user the bit goes from 1 to 0 and 1 to 0 going from kernerl to user in executing a program 

WE KNOW THAT HARDWARE-KERNEL-SHELL-USER 
SYSTEM CALL-THE CALLS THAT WE DO TO GO TO KERNEL ,IT IS AN INSTRUCTION THAT REQUESTS THE OS TO PERFORM THE DESIRED OPERATION THAT NEEDS HARD WARE ACCESS OR OTHER PRIVILAGED OPERATION(WHICH REQUIRE A DEDICATED SYSTEM)

TYPES OF SYSTEM CALL-(not completed)
1 PROCESS CONTROL-IN WINDOWS CREATEPROCESS() AND FORK() IN WINDOWS AND LINUX FOR THE PROCESS CREATING, AND TO END PROCESS IN WINDOWS USE EXITPROCESS() AND IN LINXUS EXIT()
fork() generally contains 3 values-0(child process),+(parent process),-1(child not created) 
SEE IMAGES FOR PARENT CHILD CLASS NUMERICALS
-1 fork only when fork dosent execute
WAIT FOR A SINGLE OBJECT-IN UNIX 

2 FILE MANAGEMENT SYSTEM CALL-TO DESTROY,OPEN,READ,WRITE,CREATE ALL THESE ARE IN FILE MANAGEMENT

3 DEVICE MANAGEMENT-TO CONTROL WHICH MODE IS THE DEVICE WORKING ON AND TO READ AND WRITE THE CONSOLE ,SET TIMERS 

4INFORMATION MAINTENANCE/MANAGEMENT-GETCURRENTPROCESSID() in windows and settime() setsleep() windows and in unix/linux 
getpid() retrives current process id ,alarm() sleep() 

5security purposes-reading writing and execution mode ,chmod() function in linux ,setfilesecurity() is for shell commanding windows,initializing the security for descriptor

6 COMMUNICATION SYSTEM CALLS -























                                                                                                                                                                                                                                                                                                                                                                              