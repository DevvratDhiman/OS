PROCESS STATE-process state is just a model for the user to understand what states
a process goes through while it grows from start to termination

PRIMARY STATES- NEW ,READY, RUNNING ,TERMINATION ,WAIT 

NEW-when a process is created 

READY QUEUE-when the process pop from new state to ready state or RAM (only a selected 
processes get selected to go in ram as its limited by using long term scheduler)

LHS-LONG TERM SCHEDULER-THIS WANTS TO GET AS MUCH PROCESSES AS POSSIBLE IN READY QUEUE
OR RAM ,(THIS IS MULTI PROGRAMMING)

NOW WHAT WE WILL DO IS WE WILL EXECUTE THOSE PROCESSES,NOW FROM ALL PROCESSES IN READY
QUEUE ARE SELECTED TO BE DISPACTED OR SCHEDULED IN RUNNING STATE BY GIVING IT CPU
DEPEDING ON CPU WE CAN HAVE AS MANY PROCESSES BY NO OF CPU 
IN UNIPROCESS SYSTEM WE HAVE 1 CPU,SO WE TAKE 1 PROCESS TO BE DISPATCHED/SCHEDULED 
TO EXECUTE 

RUNNING STATE-THE RUNNING PROCESS IS STILL UNDER THE RAM BUT NOW ITS STATE HAS
CHANGED ,IT HAS GOT A NEW ADRESS AND IS BEING EXECUTED BY CPU

TERMINATION-CPU WILL EXEUTED ALL OF INSTRUCTIONS OF PROCESS UNTIL IT IS FINISHED 
THEN IT WILL GET COMPLETED AND DEALLOCATION WILL OCCUR,AKA ITS SPACE IN RAM WILL BE
FREED AS RAM IS LIMITED

SHORT TERM SCHEDULER-WHOSE JOB IS TO THROW THE PROCESS IN RUNNING STATE/CPU,IF 
ANY CASE OCCURS WHERE WE NEED TO RETURN THE PROCESS IN WORKING TO READY QUEUE FOR
LATER EXECUTION LIKE IN ROUND ROBIN
THIS IS A PREMPTIVE SCHEDULING-WHERE CONTEXT SWITCHING OCCUR

HIGH PRIORITY-WHEN CPU IS ALREADY RUNNING A PROCESS BUT A HIGH PRIORITY PROCESS COMES
THEN CPU IS OBLIGED TO STOP AND AND THROW CURRENT PROCESS IN READY QUEUE AND EXECUTE 
THE HIGH PRIORITY PROCESS(THIS IS EXAMPLE FOR UNARY SYSTEM)(MULTI TASKING EXAMPLE)

SECOND REASON FOR MULTI TASKING IS TIME QUNATUM LIKE IN ROUND ROBIN WHERE WE ONLY RUN
A CERTAIN PROCESS FOR SOME TIME QUNATUM AND KEEP CHANGING THE PROCESS WHEN THE PROCESSES
TIME QUANTUM IS FINISHED 

I/O REQUEST-
LETS SUPPOSE CPU IS RUNNING A PROCESS BUT IN BETWEEN THE PROCESS ASKS FOR I/O PERMISSION
THAT IT WANTS TO READ A FILE OR ASK FOR INPUT,NOW ITS ALL PRESENT IN THE SECONDARY MEMORY
WHICH DOES NOT COME UNDER THE CPU JURISDICTION AS ITS A PART OF RAM AND NOT HDD 

SO THE CPU SENDS IT TO A WAITING OR BLOCK AREA WHICH IS PRESENT IN THE RAM BUT IS DIFFERENT
WHY IT HAPPENS IS DUE THAT CPU IS FASSSSSSSSSSSSSSST AND SECONDARY MEMORY IS SLOW
SO CPU WONT WAIT FOR THE PROCESS TO SLOWLY READ THE FILE OR GET I/O AND JUST THROWS 
IT IN WAITING QUEUE

THEN THE PROCESS GOES BACK TO READY QUEUE AFTER GETTING ITS I/O AND GETS CPU AGAIN 

MEDIUM TERM SCHEDULER-
IMP-IF ALL OR A LOT OF PROCESSES GET IN WAITING STATE FOR I/O ,AS RAM IS LIMITED
SO A SUSPEND WAIT IS CREATED AND THOSE PROCESSES ARE SWAPPED OUT AKA THEY ARE THROWN
OUT OF SECONDARY MEMORY AND DO ITS I/O THERE AND NOT IN WAITING QUEUE 
AFTER DONE IT GETS BACK TO WAIT QUEUE AND GET INTO READY STATE AND GET CPU AGAIN
OR IF WAITING QUEUE GETS EMPTY THEN THOSE PROCESSES START TO RETURN TO WAITING QUEUE 
OR IF MORE PROCESSES GET FILLED IN READY QUEUE EVEN AFTER SUSPEND WAIT
THEN WE WILL HAVE BLACKSTORE WHERE ALL SUSPEND WAIT ARE THROW TO SUSPEND READY ONLY IF
READY QUEUE IS ALSO FILLED ,ALL THIS IS DONE BY MID SCHEDULER 

ANOTHER CASE WHERE ALL OF READY QUEUE GETS FILLED THEN THE NEW STATE QEUE WILL BE 
BLOCKED FOR SOME TIME FOR READY QUEUE BUT!!! A VIP PROCESS COMES IN NEW STATE
HAVING HIGH PRIO BUT OUR READY QUEUE IS FILLED,THEN WE THROW THOSE PROCESSES IN READY
QUEUE IN SUSPEND READY PROCESSES AND MAKE WAY FOR HIGH PRIO